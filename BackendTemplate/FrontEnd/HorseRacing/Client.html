<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>ƒêua ng·ª±a</title>
	<script src="BGEngine.js"></script>
</head>

<body>
	<canvas id="myCanvas" style="border:1px solid #000000;"></canvas>
	<script>
		const canvas = document.getElementById("myCanvas");
		canvas.width = window.innerWidth - 22;
		canvas.height = window.innerHeight - 22;
		gameEngine.initCanvas(canvas);
		window.addEventListener('resize', function () {
			canvas.width = window.innerWidth - 22;
			canvas.height = window.innerHeight - 22;
			gameEngine.initCanvas(canvas);
		});

		class Ultilities {
			static createBtn = (text = 'Button', _event = null, _top = 0, _left = 0, _position = '') => {
				const btn = document.createElement('button');
				btn.innerText = text;
				if (_position == '')
					btn.style.position = 'absolute';
				else
					btn.style.position = _position;
				btn.style.top = `${_top}px`;
				btn.style.left = `${_left}px`;
				// btn.addEventListener('click', _event != null ? _event : () => {
				btn.addEventListener('click', _event != null ? _event : () => {
					if (_event != null)
						_event();
					btn.remove();
				})
				document.body.appendChild(btn);
				return btn;
			}

			static lerp(start, end, t) {
				const val = (1 - t) * start + t * end;
				return val;
			}
		}
		class F {
			static CMD = "cmd";
			static OLD_STATE = "oS";
			static NEW_STATE = "nS";
			static GAME_DETAILS = "gDs";
			static USER_ID = "uid";
			static USERNAME = "u";
			static MONEY = "m";
			static AVATAR = "a";
			static GENDER = "g";
			static PLAYER = "p";
			static TYPE = "t";
			static CODE = "c";
			static BETTING = "b";
			static CARDS = "cs";
			static FROM_PLAYER = "fP";
			static TO_PLAYER = "tP";
			static PLAYER_STATE = "pS";
			static MONEY_EXCHANGE = "mX";
			static PLAYERS = "ps";
			static GROUP_NAME = "G";
			static ROOM_ID = "rid";
			static ROOM_NAME = "rn";
			static MIN_MONEY = "mM";
			static ROOMS = "rs";
			static GAME_TYPE = "gT";
			static USER_COUNT = "uC";
			static MAX_USER = "Mu";
			static TOTAL_USER_COUNT = "tUC";
			static GAME_STATE = "gS";
			static IS_ROOM_MASTER = "C"; // captain
			static REASON = "rea";
			static POSITION = "sit"; // vi tri
			static REMAINING_TIME = "rmT";
			static USER_ASSETS = "As";
			static BROADCAST_MESSAGE = "bcm";
			static ACCESS_TOKEN = "accessToken";
			static MERCURY_ACCESS_TOKEN = "mercury:accessToken";
			static USERS = "us";
			static DATA = "d";
			static DISPLAY_NAME = "dn";
			static NEXT_CMD = "nCmd";
			static LOST_MONEY = "lm";
			static LAST_ROOM = "lr";
			static READY = "r";
			static TIME = "T";
			static PLAYING = "pi";
			static RECONNECT = "re";
			static GAME_ID = "gid";
			static SERVER_ID = "sid";
			static ZONE_NAME = "zn";
			static ID = "id";
			static HAZELCAST = "hazelcast";
			static LAST_DISCARDS = "ldc";
			static ASSET_ID = "aid";
			static _ID = "_id";
			static SEQ = "seq";
			static MUST_UPDATE_USERNAME = "muu";
			static ID_PRODUCER = "idProducer";
			static FROM_USER = "fu";
			static ROOM_INFO = "ri";
			static SUBSCRIBLE_INVITE = "subi";
			static PLATFORM_ID = "pid";
			static LIST_PLAYING = "lpi";
			static PHONE = "ph";
			static PHONE_VERIFIED = "pvr";
			static CURRENT_PLAYER = "cP";
			static PREV_USER_ID = "puid";
			static TIME_FOR_TURN = "tft";
			static MIN_MONEY_BUY_IN = "mMBI";
			static MAX_MONEY_BUY_IN = "MMBI";
			static REAL_MONEY = "rM";
			static POTS = "pots";
			static WINNERS = "wns";
			static IS_WINNER = "iw";
			static MESSAGE = "mgs";
			static SUCCESS = "scc";
			static MAX_MONEY_CREATE_ROOM = "Mmcr";
			static MIN_MONEY_CREATE_ROOM = "mmcr";
			static MAX_BETTING = "mB";
			static NAME = "name";
			static UNREAD = "ur";
			static NEW_ANNOUNCE = "na";
			static ACTIVE_MESSAGE = "am";
			static TIME_FOR_END_GAME = "tfeg";
			static VALUE = "v";
			static BALANCE = "ba";
			static JAR = "jar";
			static JAR_ID = "jid";
			static ENABLE_JAR_OF_THREE_CARDS = "ejotc";
			static JARS = "js";
			static BETTINGS = "bs";
			static IS_JOIN = "iJ";
			static URL = "url";
			static VERIFY_MESSAGE = "vm";
			static GROUP_ID = "grI";
			static DEFAULT_BETTING = "dfB";
			static TIME_FOR_READY = "tFR";
			static TIME_FOR_START = "tFS";
			static TIME_FOR_DEAL_CARD = "tFDC";
			static TURN_REMAINING_TIME = "tRMT";
			static IS_READY = "isR";
			static ENTRY_ID = "eid";
			static IS_BOT = "ib";
			static GAME_MODE = "gM";
			static METADATA = "rMt";
			static LOAN_MONEY = "loan";
			static MAX_LOAN = "mL";
			static IS_SHOW = "is";
			static IS_FRIEND = "iF";
			static TO_USER = "tu";
			static FRIENDS = "fris";
			static CHANNELS = "chs";
			static CHANNEL = "ch";
			static TIMESTAMP = "tst";
			static TOURNAMENT_INFO = "tournamentInfo";
			static IS_TOURNAMENT = "iTmt";
			static CHAT_HISTORY = "cH";
			static FROM_USERNAME = "fun";
			static TO_USERNAME = "tun";
			static TIME_FOR_BETTING = "tfb";
			static ROOM_BETTINGS = "rbs";
			static TIME_FOR_BOOKING = "tfb";
			static INCOGNITO = "inc";
			static PASSWORD = "pwd";
			static HAS_PASSWORD = "hpwd";
			static MAX_BET = "MB";
			static JACKPOTS = "Js";
			static HUGE = "hg";
			static DRAW_ID = "d";
			static COUNT_DOWN = "c";
			static CCU_GAMES = "cgs";
			static CCU = "ccu";
			static VERIFIED_BANK_ACCOUNT = "vba";
			static LIMIT = "L";
			static SKIP = "S";
			static SKIP_LOGOUT_MESSAGE = "slom";
			static BRAND = "br";
		}
		class CMD {
			static C_JOIN_GAME = 10001;
			static S_JOIN_GAME = 10002;
			static S_PLAYER_JOIN_GAME = 10003;

			static C_LEFT_GAME = 10011;
			static S_LEFT_GAME = 10012;
			static S_PLAYER_LEFT_GAME = 10013;


			static C_ADD_BET = 20001;
			static S_ADD_BET = 20002;
			static S_ADD_BET_Invalid = 20003;
			static S_PLAYER_ADD_BET = 20009;

			static S_FINISH_GAME = 20900;
		}


		class sceneLogin extends GameScene {
			constructor() { super("aaaaaa"); }
			onInit() {
				Ultilities.createBtn('Scene Bet', () => {
					gameEngine.changeScene(new BetScene());
					console.log("aaaaaa");
				});
				this.img = new Image();
				this.background = new Image();
				this.background.src = '../UI/map/range.png';
				this.startBackground = new Image();
				this.startBackground.src = '../UI/map/line-start.png';
				this.endBackground = new Image();
				this.endBackground.src = '../UI/map/line-finish.png';

				this.backgroundPosition = 0;
				this.finishLinePos = 0;
				this.startPosition = 0;
				this.startDraw = (canvas.height / 2) - 129 * 2;
				this.backgroundSpeed = 1;
				this.currentBGPos = 0;
				this.isRace = false;
				this.isWaitToFinish = false;
				this.isFinishGame = false;
				this.isHaveResult = false;
				this.secondHorseId = -1;
				this.firstHorseId = -1;

				// Horse Data
				// this.horseSpeed = 0.005;
				this.horseSpeed = 0.001;
				this.rankPosition = [50, 100, 150, 200, 250, 300, 350, 400, 450];
				this.horeseRank = [0, 0, 0, 0, 0, 0, 0, 0];
				this.currentHorsePos = [0, 0, 0, 0, 0, 0, 0, 0];
				this.idleAnim = new GameSprite(75);
				this.runAnim = new GameSprite(40);

				this.backgroundCountX = canvas.width / 194 + 1;
				this.backgroundCountY = 4;

				// Time count down to race
				this.timeCountDown = Date.now();
				for (let i = 1; i <= 6; i++) {
					this.idleAnim.addAnimation(`../UI/Animation/Idle/128x128/Idle_Frame${i}.png`, i - 1);
				}
				for (let i = 1; i <= 11; i++) {
					this.runAnim.addAnimation(`../UI/Animation/Run/128x128/Run_Frame${i}.png`, i - 1);
				}
			}
			onUpdate() {
				//console.log("ƒêang ·ªü trong Scene("+this.sceneName+") |||||| "+gameEngine.FPS);
				gameEngine.ctx.strokeStyle = "yellow";
				gameEngine.ctx.beginPath();
				gameEngine.ctx.moveTo(10, 45);
				gameEngine.ctx.lineTo(window.innerWidth - 32, 45);
				// Make the line visible
				gameEngine.ctx.stroke();
				gameEngine.ctx.strokeStyle = "blue";

				gameEngine.ctx.fillStyle = "red";
				gameEngine.ctx.fillRect(0, 540, 1080, 1);

				if (this.isWaitToFinish == false) {
					if (this.isRace == false) {
						// 3000 3S count down before race
						if (Date.now() - this.timeCountDown >= 3000) {
							this.isRace = true;
							this.timeCountDown = Date.now();
							// TODO force add horse rank here
						}
					} else {
						if (this.isHaveResult == false) {
							const arr = this.runAnim.randomRank(this.horeseRank);
							if (arr != null) {
								this.horeseRank = arr;
							}
						}
					}
				}

				// this.ctx.fillStyle = "#FFA500";
				// this.ctx.fillText("üëè FPS : "+gameEngine.FPS, 200, 200);
			}
			onDraw() {
				for (let k = 0; k < this.backgroundCountY; k++) {
					for (let i = 0; i < 150; i++) {
						const position = this.background.width * i + this.currentBGPos;
						if ((-194) <= position && position <= canvas.width) {
							gameEngine.ctx.drawImage(
								this.background,
								position,
								this.startDraw + this.background.height * k);
						}
					}
				}

				// 214x517 is size X of the background
				if ((-this.startBackground.width) <= this.currentBGPos && this.currentBGPos <= canvas.width) {
					// Draw startline
					gameEngine.ctx.drawImage(
						this.startBackground,
						this.currentBGPos,
						this.startDraw);
				}

				if (this.isHaveResult) {
					gameEngine.ctx.drawImage(
						this.endBackground,
						canvas.width + this.finishLinePos,
						this.startDraw);
				}


				if (this.isRace) {
					for (let i = 0; i < 8; i++) {
						const horsePos = Ultilities.lerp(this.currentHorsePos[i], this.rankPosition[this.horeseRank[i]], this.horseSpeed);
						this.currentHorsePos[i] = horsePos;
						this.runAnim.draw(horsePos, this.startDraw - 64 + 64 * i, this.isFinishGame);
					}

					if (this.isWaitToFinish == false) {
						if (Date.now() - this.timeCountDown >= 5000) {
							this.timeCountDown = Date.now();

							if (this.isHaveResult) {
								this.isWaitToFinish = true;
							} else {
								this.secondHorseId = 0;
								this.firstHorseId = 7;
								const arr = this.runAnim.randomRank(this.horeseRank, this.firstHorseId, this.secondHorseId, true);
								this.horeseRank = arr;
								this.isHaveResult = true;
							}
						}
					} else {
						// Finish game -> stop bg and horse move foward
						if (Date.now() - this.timeCountDown >= 2000) {
							this.backgroundSpeed = 0;
							this.isRace = false;
							this.horseSpeed = 1;
							console.log("Finish game, STOP race: this.isRace = false");
						}
						this.finishLinePos -= this.backgroundSpeed;
					}
					this.currentBGPos -= this.backgroundSpeed;
				} else {

					if (this.isWaitToFinish) {
						for (let i = 0; i < 8; i++) {
							this.currentHorsePos[i] += this.horseSpeed;
							this.runAnim.draw(this.currentHorsePos[i], this.startDraw - 64 + 64 * i, this.isFinishGame);
						}

						if (this.isFinishGame == false) {
							if (this.currentHorsePos[this.secondHorseId] + this.runAnim.img[this.runAnim.currentFrame].width >= (canvas.width + this.finishLinePos)) {
								this.isFinishGame = true;
								this.horseSpeed = 0;
							}
						}
					} else {
						for (let i = 0; i < 8; i++) {
							this.idleAnim.draw(0, this.startDraw - 64 + 64 * i, this.isFinishGame);
						}
					}
				}
				if (this.isFinishGame) {
					const popupWidth = window.innerWidth - 22;
					const popupHeight = window.innerHeight - 22;
					gameEngine.ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
					gameEngine.ctx.fillRect(0, 0, popupWidth, popupHeight);


					// V·∫Ω ng·ª±a th·∫Øng
					const winnerHorseImage = new Image();
					winnerHorseImage.src = `../UI/BetScene/HorseAvatar/Avatar/Horse_${this.firstHorseId + 1}.png`;
					gameEngine.ctx.drawImage(winnerHorseImage, 0, 0, 300, 300);

					const goldMedal = new Image();
					goldMedal.src = `../UI/BetScene/HorseAvatar/Avatar/1st.png`;
					gameEngine.ctx.drawImage(goldMedal, 500, 0, 193, 300);

					// V·∫Ω ng·ª±a nh√¨
					const secondHorseImage = new Image();
					secondHorseImage.src = `../UI/BetScene/HorseAvatar/Avatar/Horse_${this.secondHorseId + 1}.png`;
					gameEngine.ctx.drawImage(secondHorseImage, 0, 320, 300, 300);
					const silvelMedal = new Image();
					silvelMedal.src = `../UI/BetScene/HorseAvatar/Avatar/2nd.png`;
					gameEngine.ctx.drawImage(silvelMedal, 500, 320, 193, 300);
				}
			}
		}

		class GameSprite {
			constructor(_animationRate) {
				this.img = [];
				this.timeAnimation = Date.now();
				this.currentFrame = 1;
				this.animationRate = _animationRate;
				this.ramdonRankRate = Date.now();
			}

			addAnimation(url, index) {
				this.img[index] = new Image();
				this.img[index].src = url;
			}

			draw(_x, _y, _isStopGame) {
				if (_isStopGame == false) {
					if (Date.now() - this.timeAnimation > this.animationRate) {
						this.timeAnimation = Date.now();
						if (this.currentFrame == this.img.length - 1)
							this.currentFrame = 1;
						else
							this.currentFrame++;
					}
				}

				gameEngine.ctx.drawImage(
					this.img[this.currentFrame],
					_x,
					_y,
					128, 128);
			}

			randomRank(_horseRank, first = -1, second = -1, force = false) {
				if (Date.now() - this.ramdonRankRate > 3000 || force) {
					const arr = [];
					this.ramdonRankRate = Date.now();
					for (let i = 0; i < _horseRank.length; i++) {
						const val = this.getRandomInt(1, 8);
						// _horseRank[i] = val;
						arr[i] = val;

						if (force) {
							if (arr[i] == 7)
								arr[i] -= 1;
							else if (arr[i] == 8)
								arr[i] -= 2;
						}
					}
					if (force) {
						arr[first] = 8;
						arr[second] = 7;
					}

					let db = "";
					for (let i = 0; i < arr.length; i++)
						db += arr[i] + ", ";
					console.log(db);
					return arr;
				}
				return null;
			}



			getRandomInt(min, max) {
				min = Math.ceil(min);
				max = Math.floor(max);
				const val = Math.floor(Math.random() * (max - min + 1)) + min;
				// console.log("Value: "+ val);
				return val;
			}
		}

		gameEngine.changeScene(new sceneLogin());

		class BetScene extends GameScene {
			constructor() { super("BetScene"); }
			onInit() {
				this.img = [];
				for (let i = 1; i <= 8; i++) {
					this.img[i - 1] = new Image();
					this.img[i - 1].src = `../UI/BetScene/HorseAvatar/Background/BG_${i}.png`;
				}

				this.imgHorse = [];
				for (let i = 1; i <= 8; i++) {
					this.imgHorse[i - 1] = new Image();
					this.imgHorse[i - 1].src = `../UI/BetScene/HorseAvatar/Avatar/Horse_${i}.png`;
				}

				this.imgCup = new Image();
				this.imgCup.src = '../UI/BetScene/Cup.png';

				this.imgCoin = new Image();
				this.imgCoin.src = '../UI/BetScene/UserCoin.png';

				this.betTableOffset = {
					x: 50,
					y: 50,
					width: 874,
					height: 460,
					bet: "0"
				};

				this.historyTableOffset = {
					x: 1150,
					y: 50,
					width: 259,
					height: 460,
					tiltle: 'HISTORY',
					content: [],
				};
				this.historyTableOffset.content.push("2 - 3")
				this.historyTableOffset.content.push("3 - 2")
				this.historyTableOffset.content.push("4 - 2")
				this.historyTableOffset.content.push("1 - 3")

				this.userInfoOffset = {
					x: 50,
					y: 580,
					width: 400,
					height: 140,
				};

				this.horseOffset = 20;

				// Chips and holder
				// Holder size with 16:9: 1025, 165
				this.chipHoldingId = 1;
				this.imgChips = [];
				for (let i = 0; i < 27; i++) {
					this.imgChips[i] = new Image();
					this.imgChips[i].src = `../UI/BetScene/ChipsID/Chip_${i + 1}.png`;
				}
				this.imgArrows = {
					left: new Image(),
					right: new Image(),
					width: 90,
					height: 90
				}
				this.imgArrows.left.src = `../UI/BetScene/ArrowHolder.png`;
				this.imgArrows.right.src = `../UI/BetScene/ArrowHolderRight.png`;

				this.imgChipHolder = new Image();
				this.imgChipHolder.src = `../UI/BetScene/ChipHolder.png`;
				this.chipOffset = 20;
				this.holderOffset = {
					x: canvas.width * 0.3,
					y: canvas.height - 165 - 10,
					arrow: canvas.width * 0.3 + 30,
					chipStart: canvas.width * 0.3 + 120,
					chipEnd: 96 * 7 + this.chipOffset * 7,
					width: 1025,
					height: 165,
					chipSize: 96
				}
				this.chipAnimation = {
					scale: {
						speed: 0.01,
						value: 1.28,
						currentSize: this.holderOffset.chipSize,
						isScaleUp: true
					},
					move: {
						speed: 0.005,
						currentPosX: this.holderOffset.chipStart + this.chipOffset * this.chipHoldingId + this.holderOffset.chipSize * this.chipHoldingId,
						currentPosY: this.holderOffset.y + this.holderOffset.height / 5.5,
					},
					speedMove: 0.001,
				}
				this.moveChipToBet = {
					id: 1,
					speed: 0.01,
					chips: [] // chip have currentX and currentY to lerp, target X and target Y
				}
				this.slidePage = 0;
				this.valueEachPage = this.holderOffset.chipStart + this.chipOffset * 6 + this.holderOffset.chipSize * 7;
			}
			onUpdate() {
				
			}
			onDraw() {
				// betTable
				gameEngine.ctx.fillStyle = "red";
				gameEngine.ctx.fillRect(
					this.betTableOffset.x,
					this.betTableOffset.y,
					this.betTableOffset.width,
					this.betTableOffset.height);

				let spriteValue = 0;

				for (let i = 0; i < 3; i++) {
					for (let k = 0; k < 3; k++) {
						if (i == 2 && k == 2)
							break;
						gameEngine.ctx.drawImage(
							this.img[spriteValue],
							this.betTableOffset.x + 265 * i + this.horseOffset + + this.horseOffset * i,
							this.betTableOffset.y + 125 * k + this.horseOffset + this.horseOffset * k,
							265, 125);
						spriteValue++;
					}
				}

				let HorseAvatar = 0;

				for (let i = 0; i < 3; i++) {
					for (let k = 0; k < 3; k++) {
						if (i == 2 && k == 2)
							break;
						gameEngine.ctx.drawImage(
							this.imgHorse[HorseAvatar],
							this.betTableOffset.x + 265 * i + this.horseOffset + 3 + this.horseOffset * i,
							this.betTableOffset.y + 125 * k + this.horseOffset + 14 + this.horseOffset * k,
							116, 110);
						HorseAvatar++;
					}
				}
				gameEngine.ctx.font = "40px Time New Romen";
				gameEngine.ctx.fillStyle = "yellow";
				gameEngine.ctx.fillText(
					this.betTableOffset.bet,
					this.betTableOffset.x + this.horseOffset,
					this.betTableOffset.y + 125 * i + this.horseOffset + 15 + this.horseOffset * i,
				)

				//historyBG
				gameEngine.ctx.fillStyle = "red";
				gameEngine.ctx.fillRect(
					this.historyTableOffset.x,
					this.historyTableOffset.y,
					this.historyTableOffset.width,
					this.historyTableOffset.height);

				gameEngine.ctx.drawImage(
					this.imgCup,
					this.historyTableOffset.x + this.historyTableOffset.width - this.imgCup.width / 2,
					this.historyTableOffset.y - this.imgCup.height / 2,
				);

				gameEngine.ctx.font = "50px Time New Romen";

				gameEngine.ctx.fillStyle = "white";

				gameEngine.ctx.fillText(
					this.historyTableOffset.tiltle,
					this.historyTableOffset.x + 33,
					this.historyTableOffset.y + 65,
				);

				for (var i = 0; i < this.historyTableOffset.content.length; i++) {
					gameEngine.ctx.font = "80px Time New Romen";

					gameEngine.ctx.fillText(
						this.historyTableOffset.content[i],
						this.historyTableOffset.x + 60,
						this.historyTableOffset.y + this.historyTableOffset.height / 3 + i * 90,
					);
				}


				//userBG
				gameEngine.ctx.fillStyle = "red";
				gameEngine.ctx.fillRect(
					this.userInfoOffset.x,
					this.userInfoOffset.y,
					this.userInfoOffset.width,
					this.userInfoOffset.height
				);

				gameEngine.ctx.fillStyle = "white";
				gameEngine.ctx.fillRect(
					this.userInfoOffset.x + this.userInfoOffset.width / 2.7,
					this.userInfoOffset.y + 10,
					220, 50,
				);

				gameEngine.ctx.drawImage(
					this.imgCoin,
					this.userInfoOffset.x + this.userInfoOffset.width / 2.7 - this.imgCoin.width / 4,
					this.userInfoOffset.y + 4,
					65, 65,
				);

				gameEngine.ctx.fillStyle = "white";
				gameEngine.ctx.fillRect(
					this.userInfoOffset.x + this.userInfoOffset.width / 2.7,
					this.userInfoOffset.y + this.userInfoOffset.height / 2 + 13,
					220, 50,
				);

				// Draw holder
				gameEngine.ctx.drawImage(
					this.imgChipHolder,
					this.holderOffset.x,
					this.holderOffset.y,
					this.holderOffset.width, this.holderOffset.height
				)

				let scaleUpValue = 1;
				let moveValue = 0;
				// Draw chips
				
				for (let i = 0; i < 27; i++) {
					// Scale and move chip
					let chipX = this.holderOffset.chipStart + this.chipOffset * i + this.holderOffset.chipSize * i + this.slidePage;
					let chipY = this.holderOffset.y + this.holderOffset.height / 5.5;
					let chipSize = this.holderOffset.chipSize;
					if (i == this.chipHoldingId) {
						if (this.chipAnimation.scale.isScaleUp) {
							scaleUpValue = this.chipAnimation.scale.value;
							moveValue = this.chipOffset;
						}
						chipX = Ultilities.lerp(this.chipAnimation.move.currentPosX, chipX - moveValue, this.chipAnimation.move.speed);
						chipY = Ultilities.lerp(this.chipAnimation.move.currentPosY, chipY - moveValue + 5, this.chipAnimation.move.speed);
						chipSize = Ultilities.lerp(this.chipAnimation.scale.currentSize, this.holderOffset.chipSize * scaleUpValue, this.chipAnimation.scale.speed);
						this.chipAnimation.scale.currentSize = chipSize;
						this.chipAnimation.move.currentPosX = chipX;
						this.chipAnimation.move.currentPosY = chipY;

						if (this.chipAnimation.scale.currentSize >= (this.holderOffset.chipSize * scaleUpValue - 5))
							this.chipAnimation.scale.isScaleUp = false
						if (this.chipAnimation.scale.currentSize <= (this.holderOffset.chipSize + 5))
							this.chipAnimation.scale.isScaleUp = true
					}

					console.log(`${this.holderOffset.chipStart}, Pos: ${chipX}, End: ${this.holderOffset.x - 120}`)
					if (this.holderOffset.chipStart <= chipX && chipX >= this.holderOffset.x + this.holderOffset.width - 120){
						
					}else{
						gameEngine.ctx.drawImage(
							this.imgChips[i],
							chipX,
							chipY,
							chipSize, chipSize
						)
					}
				}

				// Move chip to target 
				for (let i = 0; i < this.moveChipToBet.chips.length; i++) {
					const chipX = Ultilities.lerp(
						this.moveChipToBet.chips[i].currentPosX,
						this.moveChipToBet.chips[i].targetPosX,
						this.moveChipToBet.speed);
					const chipY = Ultilities.lerp(
						this.moveChipToBet.chips[i].currentPosY,
						this.moveChipToBet.chips[i].targetPosY,
						this.moveChipToBet.speed);

					gameEngine.ctx.drawImage(
						this.imgChips[this.moveChipToBet.chips[i].id],
						chipX,
						chipY,
						this.holderOffset.chipSize,
						this.holderOffset.chipSize);

					this.moveChipToBet.chips[i].currentPosX = chipX;
					this.moveChipToBet.chips[i].currentPosY = chipY;

					if (this.moveChipToBet.chips[i].currentPosY <= this.moveChipToBet.chips[i].targetPosY - 10){
						this.moveChipToBet.chips.splice(i, 1);
						console.log("remove");
					}
				}

			}
			onClick() {
				let foundObject = false;
				// Mouse on chip board
				if (this.holderOffset.x <= this.mouseX && this.mouseX <= (this.holderOffset.x + this.holderOffset.width) &&
					this.holderOffset.y <= this.mouseY && this.mouseY <= (this.holderOffset.y + this.holderOffset.height)) {
					for (let i = 0; i < 7; i++) {
						const chipX = this.holderOffset.chipStart + this.chipOffset * i + this.holderOffset.chipSize * i;
						const chipY = this.holderOffset.y + this.holderOffset.height / 5.5;
						if (chipX <= this.mouseX && this.mouseX <= chipX + this.holderOffset.chipSize &&
							chipY <= this.mouseY && this.mouseY <= chipY + this.holderOffset.chipSize) {
							if (this.chipHoldingId != i) {
								this.chipHoldingId = i;
								this.chipAnimation.move.currentPosX = chipX;
								this.chipAnimation.move.currentPosY = chipY;
							}
						}
					}
				} else if (this.betTableOffset.x <= this.mouseX && this.mouseX <= this.betTableOffset.x + this.betTableOffset.width &&
					this.betTableOffset.y <= this.mouseY && this.mouseY <= this.betTableOffset.y + this.betTableOffset.height) {
					// Check bet table
					for (let i = 0; i < 3; i++) {
						for (let k = 0; k < 3; k++) {
							if (i == 2 && k == 2)
								break;
							// Size: 265x125
							let horseX = this.betTableOffset.x + 265 * i + this.horseOffset + + this.horseOffset * i;
							let horseY = this.betTableOffset.y + 125 * k + this.horseOffset + this.horseOffset * k;

							if (horseX <= this.mouseX && this.mouseX <= horseX + 265 &&
								horseY <= this.mouseY && this.mouseY <= horseY + 125) {
								this.moveChipToBet.chips.push({
									id : this.chipHoldingId,
									currentPosX: this.holderOffset.chipStart + this.chipOffset * this.chipHoldingId + this.holderOffset.chipSize * this.chipHoldingId,
									currentPosY: this.holderOffset.y + this.holderOffset.height / 5.5,
									targetPosX: this.randomPosition(horseX+50, horseX + 215) - this.holderOffset.chipSize/2,
									targetPosY: this.randomPosition(horseY+20, horseY + 100) - this.holderOffset.chipSize/2
								});
								console.log(this.moveChipToBet.chips);
								break;
							}
						}
					}
				}
			}
			randomPosition(min, max) {
				console.log(`Min: ${min}, Max: ${max}`);
				return Math.random() * (max - min) + min;
			}
		}

		class BasicWebsocket {
			#websocket;
			constructor() {
				this.idCMD = 0;
			}
			start(_ip, _port) {
				console.log("*********************************************************************************");
				this.#websocket = new WebSocket("ws://" + _ip + ":" + _port + "/websocket");
				let _currentBasicWebsocket = this;
				this.#websocket.onopen = function (e) {
					console.log("BasicWebsocket k·∫øt n·ªëi ƒë·∫øn [" + _ip + ":" + _port + "] th√†nh c√¥ng");
					_currentBasicWebsocket.send([1, "Ri", Math.random().toString(36).slice(2), "password", null]);
				};
				this.#websocket.onclose = function (event) {
					console.log("ƒê√≥ng k·∫øt n·ªëi BasicWebsocket");
				};

				this.#websocket.onmessage = function (event) {//
					gameEngine.lastTimeWebsocket = Date.now();
					let _data = event.data;
					if (_data instanceof ArrayBuffer) {// binary frame
						console.log("BasicWebsocket receive bytearray : " + _data);
					} else {// text frame
						console.log("BasicWebsocket receive string : " + _data);
						let jsonReceive = JSON.parse(_data);
						if (jsonReceive[0] == 1) {
							const USERNAME = jsonReceive[3];
							console.log("Login v√†o zone th√†nh c√¥ng v·ªõi username : " + USERNAME);
							if (_currentBasicWebsocket.onSuccess)
								_currentBasicWebsocket.onSuccess();
						} else if (jsonReceive[0] == 5) {
							console.log("Nh·∫≠n message trong plugin CMD : " + jsonReceive[1].cmd);
							switch (jsonReceive[1].cmd) {
								case CMD.S_ADD_BET:
									console.log("L·ªói bet");
									let mgBetError = jsonReceive[1];
									_currentBasicWebsocket.onBetError(mgBetError[F.ID], mgBetError[F.CODE]);
									break;
								case CMD.S_PLAYER_ADD_BET:
									let _mg = jsonReceive[1];
									_currentBasicWebsocket.onPlayerBet(_mg[F.USERNAME], _mg[F.ID], _mg[F.LOST_MONEY], _mg[F.MONEY], _mg[F.BETTING]);
									break;
								case CMD.S_FINISH_GAME:
									let _mgF = jsonReceive[1];
									//if(_mgF[F.MONEY])
									_currentBasicWebsocket.onFinishGame(_mgF[F.ID], _mgF[F.WINNERS], _mgF[F.MONEY], _mgF[F.NEW_ANNOUNCE]);
									//else
									//_currentBasicWebsocket.onFinishGame(_mgF[F.ID],0,0,_mgF[F.NEW_ANNOUNCE]);
									break;
								default:
									console.log("Ch∆∞a x·ª≠ l√Ω CMD : " + jsonReceive[1].cmd);
							}
						} else {

						}
					}
				};

				this.#websocket.onerror = function (error) {
					console.log("BasicWebsocket get error " + error);
				};

				console.log("*********************************************************************************");
			}

			isRunning() { return this.#websocket && (this.#websocket.readyState == WebSocket.OPEN || this.#websocket.readyState == WebSocket.CONNECTING); }/*CONNECTING(0) - OPEN(1) - CLOSING(2) - CLOSED(3)*/
			send(_message) {
				console.log("=====>BasicWebsocket send : " + JSON.stringify(_message));
				this.#websocket.send(JSON.stringify(_message));
			}
			doBet(_index, _money) {
				let messageSending = {};
				messageSending["cmd"] = CMD.C_ADD_BET;
				messageSending[F.ENTRY_ID] = this.idCMD++;
				messageSending[F.ID] = _index;
				messageSending[F.BETTING] = _money;
				this.send([6, "Ri", "duanguaPlugin", messageSending]);
			}

			release() { this.#websocket.close(); }
		}

		var basicWS = new BasicWebsocket();
		basicWS.start("localhost", 8892);
		basicWS.onSuccess = () => {
			for (let i = 0; i < 15; i++)
				basicWS.doBet(i, i + 1);
		};


		basicWS.onPlayerBet = (_username, _indexBet, _lostmoney, _currentMoney, _listDesk) => {
			console.log("username(" + _username + ") + index(" + _indexBet + ") + bet(" + _lostmoney + ") money(" + _currentMoney + ") listDesk(" + _listDesk + ")");
		};
		basicWS.onBetError = (_idCMD, strError) => {
			console.log("_idCMD(" + _idCMD + ") : " + strError);
		};
		basicWS.onFinishGame = (resultIndex, winMoney, lastMoney, newScore) => {
			console.log("K·∫øt qu·∫£ : " + resultIndex + "	(" + winMoney + "," + lastMoney + ") ---> " + newScore);
		};

	</script>
</body>

</html>